In the updated implementation, we keep the values for a,c,m the same for all RNG's. We only change how the seed x is handled by the RNGs. 
Each time a particle is requesting a random value from a RNG, the RNG gets told from the particle which value 
for the seed x is to be used to generate the random value.
Thus, each particle must store its seed (in our case in the redis) and update its seed by each use of a RNG. With this storing we ensure that when using multiple RNGs, we still have the same x for all generators.
We also have to initialize each particle with a different seed, so we don't get the same values for each particle. With our approach we guarantee reproducibility, even if a particle uses different RNGs to get
its random values. To initialize each particle with a different seed, we use redis list appending logic and take the 
corresponding returned index to compute the seed. This approach is quite efficient for making sure that different particles use
different paths, because it keeps the messages to be exchanged at a minimum (only one per particle for the list appending call).
But since we only use different seeds which do not differ much from each other, we have less (pseudo) randomness.

So with our approach we get some overhead by always storing the values in the redis, but we ensure reproducibility and can compute the new RNG-values with multiple RNGs.

